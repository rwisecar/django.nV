Vulnerability Report
Reviewer 1: Rachael Wisecarver

Date: February 5, 2017


Reviewing nVisium Task Manager

# Vulnerability 1
## A1- Injection

We found an instance of an injection vulnerability in the upload view in views.py, where viewers can upload new files directly to the database.

            ```
            A1 - Injection (SQLi)
            curs = connection.cursor()
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))
            ```

Exploiting this vulnerability would enable malicious users to access secret user information from the database.

### Repair
We were able to fix this first vulnerability with the following adjustment(s):

*views.py*

            ```
            file = File(
                            name=name,
                            path=upload_path,
                            project=proj)

                        file.save()
            ```

By abstracting the file upload with the common ORM File method, and by deleting the curs.execute method, we are able to prevent malicious users from injecting code into our database.

There was another injection vulnerability in misc.py.

*misc.py*

            ```
            os.system(
                "mv " +
                uploaded_file.temporary_file_path() +
                " " +
                "%s/%s" %
                (upload_dir_path,
                 title))
            return '/static/taskManager/uploads/%s' % (title)
            ```

By allowing users to name on-disk files, we are putting our data at unnecessary risk.

### Repair
We were able to fix this first vulnerability with the following adjustment(s):

        ```
        import string
        import random

            title = ''.join(
        random.SystemRandom().choice(
            string.ascii_uppercase + string.digits) for _ in range(50))
        ```

Users don't need to be able to name the file. By making the file title a randomly generated string, we prevent malicious users from accessing private information.



# Vulnerability 2
## A2- Broken Auth
We found an instance of broken auth in forms.py. The User Form does not include all user fields in its list of fields to exclude (which prevents users from directly updating those fields in the form).

*forms.py*

        ```
        class UserForm(forms.ModelForm):
            """ User registration form """
            class Meta:
                model = User
                exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
        ```

A malicious user could exploit this vulnerability by setting any attribute they liked as part of their user model-- such as superuser status-- and gain permissions that should otherwise be denied to them.

### Repair
To repair forms.py, we can turn the blacklist into a whitelist, and keep better control over the fields we want users to have access to.

*forms.py*

```
        class UserForm(forms.ModelForm):
            """ User registration form """
            class Meta:
                model = User
                fields = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```

There was another instance of broken auth in settings.py, which uses CookieStorage for its user session storage. This allows users to access session variables without having to access the server (which is more heavily protected than cookies).

*settings.py*

        ```
        SESSION_ENGINE = "django.contrib.sessions.backends.signed_cookies"
        ```


### Repair
To repair settings.py, we can use django's default session engine, which was already configured using the settings.py's middleware classes.


# Vulnerability 3
## A3- XSS

We found an instance of an XSS vulnerability in the html template base_backend. Using the "safe" filter on user.username marks a string as not requiring further html escaping before being rendered to the user. This means that the string will be returned as raw, unsecured, unescaped javascript or html, which can be manipulated by the user on the front end.

*base_backend.html*

```
           <a data-toggle="dropdown" class="dropdown-toggle" href="#">
                    <span class="username"><i class="fa fa-user fa-fw"></i> {{ user.username|safe }}</span>
                    <b class="caret"></b>
                </a>
```

### Repair
We can repair this problem in base_backend.html by removing the safe filter.

*base_backend.html*
```
           <span class="username"><i class="fa fa-user fa-fw"></i> {{ user.username }}</span>
```

The exact same problem was present in tutorials/base.html, search.html, task_details.html, and settings.html. We can also set the SECURE_BROWSER_XSS_FILTER configuration to True in our settings.py file to prevent XSS attacks in the future.


# Vulnerability 4
## A4- Insecure DOR
We found many instances of Insecure DOR vulnerabilities in views.py. In each instance, there was no check to see whether the user was authenticated before supplying them with secure information. Here is one example:

*views.py*

```
            def download(request, file_id):

                file = File.objects.get(pk=file_id)
                abspath = open(
                    os.path.dirname(
                        os.path.realpath(__file__)) +
                    file.path,
                    'rb')
                response = HttpResponse(content=abspath.read())
                response['Content-Type'] = mimetypes.guess_type(file.path)[0]
                response['Content-Disposition'] = 'attachment; filename=%s' % file.name
                return response
```

In this instance, as in each instance of the Insecure DOR vulnerabilities, users are able to access sensitive information with no check to see whether they have the permission to access that information.

### Repair

This vulnerability can be secured by adding an authentication gate before giving access to sensitive information.

*views.py*
```
            def download(request, file_id):

                if request.user.is_authenticated():
                    file = File.objects.get(pk=file_id)
                    abspath = open(
                        os.path.dirname(
                            os.path.realpath(__file__)) +
                        file.path,
                        'rb')
                    response = HttpResponse(content=abspath.read())
                    response['Content-Type'] = mimetypes.guess_type(file.path)[0]
                    response['Content-Disposition'] = 'attachment; filename=%s' % file.name
                    return response
```

By making sure that each user is authenticated, we can prevent unauthorized access.



# Vulnerability 5
## A5 - Misconfig

We found an instance of a Misconfig vulnerability in settings.py-- the DEBUG setting and the TEMPLATE_DEBUG were each set to True. This means that malicious users could gain access to debug pages, which contain specific and sensitive information about the app.

*settings.py*

```
            DEBUG = True
            TEMPLATE_DEBUG = True
```

### Repair
We can repair this problem by setting these to False.

*settings.py*
```
            DEBUG = False
            TEMPLATE_DEBUG = False
```

If we still had Cookie Session storage enabled, that would also have triggered a misconfig vulnerability. Switching to Django's default session storage corrected that.


# Vulnerability 6
## A6- Sensitive Data Exposure
Sensitive data exposure occurs when sensitive data (such as passwords) is not sufficiently protected from user access. I found one vulnerability in settings.py- passwords are hashed, which is typically a good way to prevent malicious user access to password data- but here, they are hashed using a weak hashing algorithm. Because the MD5 algorithm is designed to work quickly and conserve memory, hackers are able (with the right hardware) to compute a very large number of MD5 hashed passwords relatively quickly. With a more secure (read: slower, more memory-intensive) hashing algorithm, hackers need much more computing power (and expensive HW) to compute each password. MD5 is just not safe.

*settings.py*

```
        PASSWORD_HASHERS = ['django.contrib.auth.hashers.MD5PasswordHasher']
```

### Repair

This vulnerability can be repaired by changing the algorithm to a slower, more memory-intensive hashing algorithm. The Django default settings are fine, but Django actually recommends using Argon2- the winner of the 2015 Password Hashing Competititon. To use Argon2, we have to:

*settings.py*
```
            pip install django[argon2]

```

And then update settings.py to include the following PASSWORD_HASHERS:

*settings.py*
```
        PASSWORD_HASHERS = [
            'django.contrib.auth.hashers.Argon2PasswordHasher',
            'django.contrib.auth.hashers.PBKDF2PasswordHasher',
            'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
            'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
            'django.contrib.auth.hashers.BCryptPasswordHasher',
        ]
```

By making sure that the passwords are properly hashed, we prevent malicious users from accessing them.


# Vulnerability 7
## A7 - Access

Any time that a POST request is allowed without a permissions check, there is a risk of access vulnerability. In views.py, the manage_groups method authenticated users, but didn't check to see whether the authenticated user actually had permission to POST before processing the POST request. Here, it actually *only* checked whether the user had the necessary permission if the request.method was *not* post.

*views.py*

```
            def manage_groups(request):

                user = request.user

                if user.is_authenticated():

                    user_list = User.objects.order_by('date_joined')

                    if request.method == 'POST':

                        post_data = request.POST.dict()

                        accesslevel = post_data["accesslevel"].strip()

                        if accesslevel in ['admin_g', 'project_managers', 'team_member']:

                            # Create the group if it doesn't already exist
                            try:
                                grp = Group.objects.get(name=accesslevel)
                            except Group.DoesNotExist:
                                grp = Group.objects.create(name=accesslevel)
                            specified_user = User.objects.get(pk=post_data["userid"])
                            # Check if the user even exists
                            if specified_user is None:
                                return redirect('/taskManager/', {'permission': False})
                            specified_user.groups.add(grp)
                            specified_user.save()
                            return render_to_response(
                                'taskManager/manage_groups.html',
                                {
                                    'users': user_list,
                                    'groups_changed': True,
                                    'logged_in': True},
                                RequestContext(request))
                        else:
                            return render_to_response(
                                'taskManager/manage_groups.html',
                                {
                                    'users': user_list,
                                    'logged_in': True},
                                RequestContext(request))

                    else:
                        if user.has_perm('can_change_group'):
                            return render_to_response(
                                'taskManager/manage_groups.html',
                                {
                                    'users': user_list,
                                    'logged_in': True},
                                RequestContext(request))
                        else:
                            return redirect('/taskManager/', {'permission': False})

                return redirect('/taskManager/', {'logged_in': False})
```

### Repair

This problem can be repaired by adding a permissions check prior to the POST request.

*views.py*
```
            def manage_groups(request):

                user = request.user

                if user.is_authenticated():

                    user_list = User.objects.order_by('date_joined')

                    if user.has_perm('can_change_group'):

                        if request.method == 'POST':

                            post_data = request.POST.dict()

                            accesslevel = post_data["accesslevel"].strip()

                            if accesslevel in ['admin_g', 'project_managers', 'team_member']:

                                # Create the group if it doesn't already exist
                                try:
                                    grp = Group.objects.get(name=accesslevel)
                                except Group.DoesNotExist:
                                    grp = Group.objects.create(name=accesslevel)
                                specified_user = User.objects.get(pk=post_data["userid"])
                                # Check if the user even exists
                                if specified_user is None:
                                    return redirect('/taskManager/', {'permission': False})
                                specified_user.groups.add(grp)
                                specified_user.save()
                                return render_to_response(
                                    'taskManager/manage_groups.html',
                                    {
                                        'users': user_list,
                                        'groups_changed': True,
                                        'logged_in': True},
                                    RequestContext(request))
                            else:
                                return render_to_response(
                                    'taskManager/manage_groups.html',
                                    {
                                        'users': user_list,
                                        'logged_in': True},
                                    RequestContext(request))
                        else:
                            return render_to_response(
                                'taskManager/manage_groups.html',
                                {
                                    'users': user_list,
                                    'logged_in': True},
                                RequestContext(request))
                    else:
                        return redirect('/taskManager/', {'permission': False})

                return redirect('/taskManager/', {'logged_in': False})
```

Now, users can only POST if they have the 'can_change_group' permission and are logged in. If they are logged in but lack the necessary permission, they get a redirect. If they aren't logged in, they get a redirect. The method is no longer vulnerable.


# Vulnerability 8
## A8 - CSRF

We found 3 instances of CSRF vulnerabilities in views.py. In each instance, the @csrf_exempt decorator was used on form methods that should have been using CSRF.

*views.py*

```
            @csrf_exempt
            def change_password(request):

                if request.method == 'POST':
                    user = request.user
                    old_password = request.POST.get('old_password')
                    new_password = request.POST.get('new_password')
                    confirm_password = request.POST.get('confirm_password')

                    if authenticate(username=user.username, password=old_password):
                        if new_password == confirm_password:
                            user.set_password(new_password)
                            user.save()
                            messages.success(request, 'Password Updated')
                        else:
                            messages.warning(request, 'Passwords do not match')
                    else:
                        messages.warning(request, 'Invalid Password')

                return render(request,
                              'taskManager/change_password.html',
                              {'user': request.user})
```

This allows malicious users to create a separate page, create a request to that page's endpoint when a user tries to change their password using the above method, and then hijack that user's valid session cookie so that the user gets the malicious page loaded, with no indication that anything has gone wrong. 

### Repair

This vulnerability can be secured by removing the @csrf_exempt decorator.

*views.py*
```
            def change_password(request):

                if request.method == 'POST':
                    user = request.user
                    old_password = request.POST.get('old_password')
                    new_password = request.POST.get('new_password')
                    confirm_password = request.POST.get('confirm_password')

                    if authenticate(username=user.username, password=old_password):
                        if new_password == confirm_password:
                            user.set_password(new_password)
                            user.save()
                            messages.success(request, 'Password Updated')
                        else:
                            messages.warning(request, 'Passwords do not match')
                    else:
                        messages.warning(request, 'Invalid Password')

                return render(request,
                              'taskManager/change_password.html',
                              {'user': request.user})
```

By making sure that each method is subject to CSRF protection, we prevent these kinds of attacks from taking place. That, in conjunction with the CSRF nonce already installed in the MIDDLEWARE_CLASSES setting in settings.py, will repair this vulnerability.