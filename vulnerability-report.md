Vulnerability Report
Reviewer 1: Rachael Wisecarver

Date: February 5, 2017


Reviewing nVisium Task Manager

# Vulnerability 1
## A1- Injection

We found an instance of an injection vulnerability in the upload view in views.py, where viewers can upload new files directly to the database.

            ```
            A1 - Injection (SQLi)
            curs = connection.cursor()
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))
            ```

Exploiting this vulnerability would enable malicious users to access secret user information from the database.

### Repair
We were able to fix this first vulnerability with the following adjustment(s):

*views.py*

            ```
            file = File(
                            name=name,
                            path=upload_path,
                            project=proj)

                        file.save()
            ```

By abstracting the file upload with the common ORM File method, and by deleting the curs.execute method, we are able to prevent malicious users from injecting code into our database.

There was another injection vulnerability in misc.py.

*misc.py*

            ```
            os.system(
                "mv " +
                uploaded_file.temporary_file_path() +
                " " +
                "%s/%s" %
                (upload_dir_path,
                 title))
            return '/static/taskManager/uploads/%s' % (title)
            ```

By allowing users to name on-disk files, we are putting our data at unnecessary risk.

### Repair
We were able to fix this first vulnerability with the following adjustment(s):

        ```
        import string
        import random

            title = ''.join(
        random.SystemRandom().choice(
            string.ascii_uppercase + string.digits) for _ in range(50))
        ```

Users don't need to be able to name the file. By making the file title a randomly generated string, we prevent malicious users from accessing private information.



# Vulnerability 2
## A2- Broken Auth
We found an instance of broken auth in forms.py. The User Form does not include all user fields in its list of fields to exclude (which prevents users from directly updating those fields in the form).

*forms.py*

        ```
        class UserForm(forms.ModelForm):
            """ User registration form """
            class Meta:
                model = User
                exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
        ```

A malicious user could exploit this vulnerability by setting any attribute they liked as part of their user model-- such as superuser status-- and gain permissions that should otherwise be denied to them.

### Repair
To repair forms.py, we can turn the blacklist into a whitelist, and keep better control over the fields we want users to have access to.

*forms.py*

```
        class UserForm(forms.ModelForm):
            """ User registration form """
            class Meta:
                model = User
                fields = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```

There was another instance of broken auth in settings.py, which uses CookieStorage for its user session storage. This allows users to access session variables without having to access the server (which is more heavily protected than cookies).

*settings.py*

        ```
        SESSION_ENGINE = "django.contrib.sessions.backends.signed_cookies"
        ```


### Repair
To repair settings.py, we can use django's default session engine, which was already configured using the settings.py's middleware classes.


# Vulnerability 3
A3- XSS

We found an instance of an XSS vulnerability in the html template base_backend. Using the "safe" filter on user.username marks a string as not requiring further html escaping before being rendered to the user. This means that the string will be returned as raw, unsecured, unescaped javascript or html, which can be manipulated by the user on the front end.

*base_backend.html*

```
           <a data-toggle="dropdown" class="dropdown-toggle" href="#">
                    <span class="username"><i class="fa fa-user fa-fw"></i> {{ user.username|safe }}</span>
                    <b class="caret"></b>
                </a>
```

### Repair
We can repair this problem in base_backend.html by removing the safe filter.

```
           <span class="username"><i class="fa fa-user fa-fw"></i> {{ user.username }}</span>
```

The exact same problem was present in tutorials/base.html, search.html, task_details.html, and settings.html. We can also set the SECURE_BROWSER_XSS_FILTER configuration to True in our settings.py file to prevent XSS attacks in the future.


# Vulnerability 4
A4- Insecure DOR
We found 12 instances of Insecure DOR vulnerabilities in views.py. In each instance, there was no check to see whether the user was authenticated before supplying them with secure information. Here is one example:

*views.py*

```
            def download(request, file_id):

                file = File.objects.get(pk=file_id)
                abspath = open(
                    os.path.dirname(
                        os.path.realpath(__file__)) +
                    file.path,
                    'rb')
                response = HttpResponse(content=abspath.read())
                response['Content-Type'] = mimetypes.guess_type(file.path)[0]
                response['Content-Disposition'] = 'attachment; filename=%s' % file.name
                return response
```

In this instance, as in each instance of the Insecure DOR vulnerabilities, users are able to access sensitive information with no check to see whether they have the permission to access that information.

### Repair

This vulnerability can be secured by adding an authentication gate before giving access to sensitive information.

```
            def download(request, file_id):

                if request.user.is_authenticated():
                    file = File.objects.get(pk=file_id)
                    abspath = open(
                        os.path.dirname(
                            os.path.realpath(__file__)) +
                        file.path,
                        'rb')
                    response = HttpResponse(content=abspath.read())
                    response['Content-Type'] = mimetypes.guess_type(file.path)[0]
                    response['Content-Disposition'] = 'attachment; filename=%s' % file.name
                    return response
```

By making sure that each user is authenticated, we can prevent unauthorized access.