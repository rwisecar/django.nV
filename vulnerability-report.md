Vulnerability Report
Reviewer 1: Rachael Wisecarver

Date: February 5, 2017


Reviewing nVisium Task Manager

# Vulnerability 1
## A1- Injection

We found an instance of an injection vulnerability in the upload view in views.py, where viewers can upload new files directly to the database.

            ```
            A1 - Injection (SQLi)
            curs = connection.cursor()
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))
            ```

Exploiting this vulnerability would enable malicious users to access secret user information from the database.

### Repair
We were able to fix this first vulnerability with the following adjustment(s):

*views.py*

            ```
            file = File(
                            name=name,
                            path=upload_path,
                            project=proj)

                        file.save()
            ```

By abstracting the file upload with the common ORM File method, and by deleting the curs.execute method, we are able to prevent malicious users from injecting code into our database.

There was another injection vulnerability in misc.py.

*misc.py*
            ```
            os.system(
                "mv " +
                uploaded_file.temporary_file_path() +
                " " +
                "%s/%s" %
                (upload_dir_path,
                 title))
            return '/static/taskManager/uploads/%s' % (title)
            ```

By allowing users to name on-disk files, we are putting our data at unnecessary risk.

### Repair
We were able to fix this first vulnerability with the following adjustment(s):

        ```
        import string
        import random

            title = ''.join(
        random.SystemRandom().choice(
            string.ascii_uppercase + string.digits) for _ in range(50))
        ```

Users don't need to be able to name the file. By making the file title a randomly generated string, we prevent malicious users from accessing private information.



# Vulnerability 2
## A2- Broken Auth
We found an instance of broken auth in forms.py. The User Form does not include all user fields in its list of fields to exclude (which prevents users from directly updating those fields in the form).

*forms.py*

        ```
        class UserForm(forms.ModelForm):
            """ User registration form """
            class Meta:
                model = User
                exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
        ```

A malicious user could exploit this vulnerability by setting any attribute they liked as part of their user model-- such as superuser status-- and gain permissions that should otherwise be denied to them.

### Repair
To repair forms.py, we can turn the blacklist into a whitelist, and keep better control over the fields we want users to have access to.

*forms.py*

```
        class UserForm(forms.ModelForm):
            """ User registration form """
            class Meta:
                model = User
                fields = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```

There was another instance of broken auth in settings.py, which uses CookieStorage for its user session storage. This allows users to access session variables without having to access the server (which is more heavily protected than cookies).

*settings.py*

        ```
        SESSION_ENGINE = "django.contrib.sessions.backends.signed_cookies"
        ```


### Repair
To repair settings.py, we can use django's default session engine, which was already configured using the settings.py's middleware classes.

*settings.py*

```
        SESSION_ENGINE = "django.contrib.sessions.models.Session"
```


# Vulnerability 3
A2- XSS
We found an instance of [vulnerability 2] by typing some relevant code into some vulnerable field OR by doing some edge-case thing.

By exploiting [this vulnerability], we were able to retrieve XYZ attributes from the site / access to some unauthorized part of the site / something else valuable.

Repair
problem_file1.py and problem_file2.py contained the vulnerability. We were able to fix the first with the following adjustment(s):

problem_file1.py

Some body of relevant code that solves our problem
problem_file2.py

Some body of relevant code that solves our problem


# Vulnerability 4
A2- Insecure DOR
We found an instance of [vulnerability 2] by typing some relevant code into some vulnerable field OR by doing some edge-case thing.

By exploiting [this vulnerability], we were able to retrieve XYZ attributes from the site / access to some unauthorized part of the site / something else valuable.

Repair
problem_file1.py and problem_file2.py contained the vulnerability. We were able to fix the first with the following adjustment(s):

problem_file1.py

Some body of relevant code that solves our problem
problem_file2.py

Some body of relevant code that solves our problem